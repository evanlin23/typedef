// src/types/gameState.ts
// No fundamental changes needed in the type definitions themselves for this refactoring.
// The structure of GameState remains the same.
// Make sure Toast is usable by GameContext.tsx by exporting it or ensuring GameContext imports it from ToastSystem.tsx
// For simplicity, assuming Toast type is available via `import { type Toast } from '../../components/ToastSystem';` in files that need it.

export interface Resources {
  ticks: number;
  maxMemory: number;
  usedMemory: number;
  entropy: number;
  aiAutoGeneratedTicks: number;
}

export interface Upgrades {
  cpuLevel: number;
  memoryLevel: number;
  optimizationLevel: number;
  aiCoreLevel: number;
  maxThreadsLevel: number;
}

export interface UpgradeCosts {
  cpu: number;
  memory: number;
  optimization: number;
  aiCore: number;
  maxThreads: number;
}

export interface MetaKnowledge {
  points: number;
  buffs: {
    tickMultiplier: number;
    costMultiplier: number;
    entropyReductionMultiplier: number;
    memoryMultiplier: number;
  };
}

export interface LayerBuff {
  id: string;
  isActive: boolean;
  expiresAt: number;
  effectMultiplier: number;
  description: string;
}

export interface ActiveLayerBuffs {
  [layerKey: string]: LayerBuff | null;
}

export interface ThreadState {
  id: number;
  code: string;
  status: 'idle' | 'running' | 'error';
  output: string;
  ticksGeneratedLastRun: number;
  acquiredLocks: string[];
}

export interface GlobalConcurrencyLocks {
    [lockName: string]: number | undefined;
}

export interface LayerSpecificStates {
  assemblyCode: string;
  assemblyOutput: string;
  highLevelCode: string;
  highLevelOutput: string;
  concurrencyThreads: ThreadState[];
  concurrencyGlobalLocks: GlobalConcurrencyLocks;
}

export interface GameState {
  resources: Resources;
  upgrades: Upgrades;
  upgradeCosts: UpgradeCosts;
  activeProcesses: number;
  
  metaKnowledge: MetaKnowledge;
  activeLayerBuffs: ActiveLayerBuffs;

  lastSaveTime: number;
  totalTicksGeneratedAllTime: number;

  autoTickEnabled: boolean;
  layerSpecificStates: LayerSpecificStates;
}

export const STORAGE_KEY = 'synthesis_game_state_v2.5'; // Incremented version
export const PRESTIGE_MK_COST_MULTIPLIER_CAP = 0.5;

export const BASE_TICK_RATE_PER_CPU_LEVEL = 0.5;
export const AI_CORE_TICK_RATE_PER_LEVEL = 0.2;
export const GAME_LOOP_INTERVAL_MS = 100;
export const MAX_ENTROPY = 100;
export const ENTROPY_PER_PROCESS_PER_SEC = 0.1;
export const OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL = 0.005;

export const CODE_COST_ASSEMBLY_PER_CHAR = 0.02;
export const CODE_COST_HIGHLEVEL_PER_CHAR = 0.01;

export const initialAssemblyCode = `MOV AX, 1
ADD AX, 5 ; Example modification
NOP ; No operation
RET`;

export const initialHighLevelCode = `// High-Level Logic Example
function calculateComplexity(input) {
  let result = 0;
  for (let i = 0; i < input; i++) {
    result += Math.pow(i, 2) / (i + 0.5);
  }
  return Math.floor(result);
}

calculateComplexity(18);
`;

export const initialConcurrencyThreadCode = (id: number): string => `// Thread ${id} - High-Level Syntax
async function processDataPart(partId) {
  // await acquireLock('shared_data_A');
  console.log(\`Thread ${id} processing part \${partId}\`);
  let sum = 0;
  for (let i = 0; i < (7 + partId); i++) {
    sum += (i * partId) + Math.random();
    await new Promise(resolve => setTimeout(resolve, 40 + Math.random() * 20)); 
  }
  // releaseLock('shared_data_A');
  return sum;
}

processDataPart(${id});`;


export const initialGameState: GameState = {
  resources: {
    ticks: 0,
    maxMemory: 64,
    usedMemory: 0,
    entropy: 0,
    aiAutoGeneratedTicks: 0,
  },
  upgrades: {
    cpuLevel: 1,
    memoryLevel: 1,
    optimizationLevel: 0,
    aiCoreLevel: 0,
    maxThreadsLevel: 1,
  },
  upgradeCosts: {
    cpu: 10,
    memory: 25,
    optimization: 50,
    aiCore: 100,
    maxThreads: 75,
  },
  activeProcesses: 0,
  metaKnowledge: {
    points: 0,
    buffs: {
      tickMultiplier: 1.0,
      costMultiplier: 1.0,
      entropyReductionMultiplier: 1.0,
      memoryMultiplier: 1.0,
    },
  },
  activeLayerBuffs: {
    assembly: null,
    highLevel: null,
    concurrency: null,
  },
  lastSaveTime: Date.now(),
  totalTicksGeneratedAllTime: 0,
  autoTickEnabled: false,
  layerSpecificStates: {
    assemblyCode: initialAssemblyCode,
    assemblyOutput: "// Assembly output will appear here",
    highLevelCode: initialHighLevelCode,
    highLevelOutput: "// High-level output will appear here",
    concurrencyThreads: [
      { 
        id: 1, 
        code: initialConcurrencyThreadCode(1), 
        status: 'idle', 
        output: '// Thread 1 ready', 
        ticksGeneratedLastRun: 0, 
        acquiredLocks: [] 
      }
    ],
    concurrencyGlobalLocks: {},
  },
};

export const calculateActualMaxMemoryValue = (memoryLevel: number, memoryMultiplier: number): number => {
  const baseMemory = 64 * Math.pow(1.5, memoryLevel - 1);
  return Math.floor(baseMemory * memoryMultiplier);
};

export const calculateTotalPotentialTickRate = (state: GameState): number => {
  const cpuTicks = BASE_TICK_RATE_PER_CPU_LEVEL * state.upgrades.cpuLevel;
  const aiTicks = AI_CORE_TICK_RATE_PER_LEVEL * state.upgrades.aiCoreLevel;
  return (cpuTicks + aiTicks) * state.metaKnowledge.buffs.tickMultiplier;
};

export const calculateEffectiveTickRate = (state: GameState): number => {
  const totalPotentialRate = calculateTotalPotentialTickRate(state);
  const entropyFactor = 1 - (state.resources.entropy / (MAX_ENTROPY * 2)); 
  return totalPotentialRate * Math.max(0, entropyFactor);
};

export const calculateMaxThreads = (state: GameState): number => {
  return 1 + state.upgrades.maxThreadsLevel;
};