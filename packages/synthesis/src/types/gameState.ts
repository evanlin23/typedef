// src/types/gameState.ts

export interface Resources {
  ticks: number;
  maxMemory: number; // Max memory capacity in "Code Units" (CU)
  usedMemory: number; // Currently used memory (approximation)
  entropy: number; // 0-100, affects efficiency
  aiAutoGeneratedTicks: number; // Tracks ticks from AI for stats
}

export interface Upgrades {
  cpuLevel: number;
  memoryLevel: number;
  optimizationLevel: number;
  aiCoreLevel: number;
  maxThreadsLevel: number; // For Concurrency Layer
}

export interface UpgradeCosts {
  cpu: number;
  memory: number;
  optimization: number;
  aiCore: number;
  maxThreads: number;
}

export interface MetaKnowledge {
  points: number;
  buffs: {
    tickMultiplier: number; // Global tick production multiplier
    costMultiplier: number; // Upgrade cost multiplier (e.g., 0.9 for 10% cheaper)
    entropyReductionMultiplier: number; // How effectively entropy is reduced or gain is slowed
    memoryMultiplier: number; // Global memory capacity multiplier
  };
}

export interface LayerBuff {
  id: string; // Unique ID for the buff effect
  isActive: boolean;
  expiresAt: number; // Timestamp for expiry (ms)
  effectMultiplier: number; // e.g., 1.2 for 20% boost to ticks from layer
  description: string;
}

export interface ActiveLayerBuffs {
  [layerKey: string]: LayerBuff | null; // e.g., 'assembly', 'highLevel', 'concurrency'
}

export interface ThreadState {
  id: number;
  code: string;
  status: 'idle' | 'running' | 'error'; // 'completed' status is merged into 'idle' post-run
  output: string;
  ticksGeneratedLastRun: number;
  acquiredLocks: string[];
}

export interface GlobalConcurrencyLocks {
    [lockName: string]: number | undefined; // lockName -> threadId holding it
}

export interface LayerSpecificStates {
  assemblyCode: string;
  assemblyOutput: string;
  highLevelCode: string;
  highLevelOutput: string;
  concurrencyThreads: ThreadState[];
  concurrencyGlobalLocks: GlobalConcurrencyLocks;
  // Future layers might add their state here
  // e.g., aiLayerScript: string;
}

export interface GameState {
  resources: Resources;
  upgrades: Upgrades;
  upgradeCosts: UpgradeCosts;
  activeProcesses: number; // Number of active non-concurrent processes
  
  metaKnowledge: MetaKnowledge;
  activeLayerBuffs: ActiveLayerBuffs;

  lastSaveTime: number;
  totalTicksGeneratedAllTime: number;

  autoTickEnabled: boolean;
  layerSpecificStates: LayerSpecificStates;
}

// Game Constants
export const BASE_TICK_RATE_PER_CPU_LEVEL = 0.5;
export const AI_CORE_TICK_RATE_PER_LEVEL = 0.2;
export const GAME_LOOP_INTERVAL_MS = 100;
export const MAX_ENTROPY = 100;
export const ENTROPY_PER_PROCESS_PER_SEC = 0.1;
export const OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL = 0.005;

export const CODE_COST_ASSEMBLY_PER_CHAR = 0.02;
export const CODE_COST_HIGHLEVEL_PER_CHAR = 0.01;

export const initialAssemblyCode = `MOV AX, 1
ADD AX, 5 ; Example modification
NOP ; No operation
RET`;

export const initialHighLevelCode = `// High-Level Logic Example
function calculateComplexity(input) {
  let result = 0;
  for (let i = 0; i < input; i++) {
    result += Math.pow(i, 2) / (i + 0.5); // Modified logic
  }
  return Math.floor(result);
}

calculateComplexity(18); // Modified input
`;

export const initialConcurrencyThreadCode = (id: number): string => `// Thread ${id} - High-Level Syntax
async function processDataPart(partId) {
  // Example of acquiring a lock for a shared resource:
  // await acquireLock('shared_data_A');
  console.log(\`Thread ${id} processing part \${partId}\`);
  let sum = 0;
  for (let i = 0; i < (7 + partId); i++) { // Vary complexity based on partId
    sum += (i * partId) + Math.random();
    // Simulate asynchronous work
    await new Promise(resolve => setTimeout(resolve, 40 + Math.random() * 20)); 
  }
  // Example of releasing a lock:
  // releaseLock('shared_data_A');
  return sum;
}

processDataPart(${id});`;


export const initialGameState: GameState = {
  resources: {
    ticks: 0,
    maxMemory: 64,
    usedMemory: 0,
    entropy: 0,
    aiAutoGeneratedTicks: 0,
  },
  upgrades: {
    cpuLevel: 1,
    memoryLevel: 1,
    optimizationLevel: 0,
    aiCoreLevel: 0,
    maxThreadsLevel: 1,
  },
  upgradeCosts: {
    cpu: 10,
    memory: 25,
    optimization: 50,
    aiCore: 100,
    maxThreads: 75,
  },
  activeProcesses: 0,
  metaKnowledge: {
    points: 0,
    buffs: {
      tickMultiplier: 1.0,
      costMultiplier: 1.0,
      entropyReductionMultiplier: 1.0,
      memoryMultiplier: 1.0,
    },
  },
  activeLayerBuffs: {
    assembly: null,
    highLevel: null,
    concurrency: null, // Ensure all potential layers are here
  },
  lastSaveTime: Date.now(),
  totalTicksGeneratedAllTime: 0,
  autoTickEnabled: false,
  layerSpecificStates: {
    assemblyCode: initialAssemblyCode,
    assemblyOutput: "// Assembly output will appear here",
    highLevelCode: initialHighLevelCode,
    highLevelOutput: "// High-level output will appear here",
    concurrencyThreads: [
      { 
        id: 1, 
        code: initialConcurrencyThreadCode(1), 
        status: 'idle', 
        output: '// Thread 1 ready', 
        ticksGeneratedLastRun: 0, 
        acquiredLocks: [] 
      }
    ],
    concurrencyGlobalLocks: {},
  },
};

// Helper Functions
export const calculateActualMaxMemory = (state: GameState): number => {
  const baseMemory = 64 * Math.pow(1.5, state.upgrades.memoryLevel - 1);
  return Math.floor(baseMemory * state.metaKnowledge.buffs.memoryMultiplier);
};

export const calculateTotalPotentialTickRate = (state: GameState): number => {
  const cpuTicks = BASE_TICK_RATE_PER_CPU_LEVEL * state.upgrades.cpuLevel;
  const aiTicks = AI_CORE_TICK_RATE_PER_LEVEL * state.upgrades.aiCoreLevel;
  return (cpuTicks + aiTicks) * state.metaKnowledge.buffs.tickMultiplier;
};

export const calculateEffectiveTickRate = (state: GameState): number => {
  const totalPotentialRate = calculateTotalPotentialTickRate(state);
  // Entropy reduces efficiency, max 50% reduction from entropy.
  const entropyFactor = 1 - (state.resources.entropy / (MAX_ENTROPY * 2)); 
  return totalPotentialRate * Math.max(0, entropyFactor); // Ensure non-negative rate
};

export const calculateMaxThreads = (state: GameState): number => {
  // Base of 1 thread, plus 1 for each level of maxThreadsLevel upgrade.
  // So, level 0 = 1 thread, level 1 = 2 threads, etc.
  // The initial state has maxThreadsLevel: 1, so it starts with 1+1 = 2 threads.
  return 1 + state.upgrades.maxThreadsLevel;
};