// src/hooks/useGameLoop.ts
import { useEffect } from 'react';
import { 
  type GameState, type ActiveLayerBuffs, 
  GAME_LOOP_INTERVAL_MS, MAX_ENTROPY, ENTROPY_PER_PROCESS_PER_SEC, 
  OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL,
  AI_CORE_TICK_RATE_PER_LEVEL,
  calculateEffectiveTickRate
} from '../types/gameState';
import { type Toast } from '../components/ToastSystem';

interface UseGameLoopProps {
  gameState: GameState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  addToast: (message: string, type?: Toast['type']) => void;
}

export const useGameLoop = ({ gameState, setGameState, addToast }: UseGameLoopProps) => {
  useEffect(() => {
    const gameLoop = setInterval(() => {
      setGameState(prev => {
        const now = Date.now();
        
        const passiveTicksPerSecond = calculateEffectiveTickRate(prev);
        const ticksThisInterval = Math.max(0, passiveTicksPerSecond / (1000 / GAME_LOOP_INTERVAL_MS));
        
        let newTicks = prev.resources.ticks + ticksThisInterval;

        const aiContributionFactor = (1 - (prev.resources.entropy / (MAX_ENTROPY * 2)));
        const aiTicksThisInterval = (AI_CORE_TICK_RATE_PER_LEVEL * prev.upgrades.aiCoreLevel * prev.metaKnowledge.buffs.tickMultiplier * aiContributionFactor) / (1000 / GAME_LOOP_INTERVAL_MS);
        
        let newAiAutoGenerated = prev.resources.aiAutoGeneratedTicks + Math.max(0, aiTicksThisInterval);
        
        const runningThreadsCount = prev.layerSpecificStates.concurrencyThreads.filter(t => t.status === 'running').length;
        const totalProcessesForEntropy = prev.activeProcesses + runningThreadsCount;

        const baseEntropyGainPerSec = totalProcessesForEntropy * ENTROPY_PER_PROCESS_PER_SEC;
        const entropyReductionPerSec = prev.upgrades.optimizationLevel * OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL * prev.metaKnowledge.buffs.entropyReductionMultiplier;
        
        const netEntropyGainPerSec = Math.max(0, baseEntropyGainPerSec - entropyReductionPerSec);
        const entropyGainThisInterval = netEntropyGainPerSec / (1000 / GAME_LOOP_INTERVAL_MS);
        const newEntropy = Math.min(MAX_ENTROPY, Math.max(0, prev.resources.entropy + entropyGainThisInterval));

        const newActiveLayerBuffs: ActiveLayerBuffs = { ...prev.activeLayerBuffs };
        (Object.keys(newActiveLayerBuffs) as Array<keyof ActiveLayerBuffs>).forEach(layerKey => {
          const buff = newActiveLayerBuffs[layerKey];
          if (buff && buff.isActive && now >= buff.expiresAt) {
            newActiveLayerBuffs[layerKey] = null; 
            addToast(`Buff for ${layerKey} layer expired.`, 'info');
          }
        });
        
        return {
          ...prev,
          resources: {
            ...prev.resources,
            ticks: newTicks,
            entropy: newEntropy,
            aiAutoGeneratedTicks: newAiAutoGenerated,
          },
          totalTicksGeneratedAllTime: prev.totalTicksGeneratedAllTime + ticksThisInterval,
          activeLayerBuffs: newActiveLayerBuffs,
        };
      });
    }, GAME_LOOP_INTERVAL_MS);
    return () => clearInterval(gameLoop);
  }, [setGameState, addToast]); 

  useEffect(() => {
    let autoTickInterval: NodeJS.Timeout | null = null;
    if (gameState.autoTickEnabled) {
      const autoClickerBaseRate = 1;
      const autoClickerCpuBonus = gameState.upgrades.cpuLevel * 0.2;
      const totalAutoClickerRate = autoClickerBaseRate + autoClickerCpuBonus;
      const effectiveManualClickRate = totalAutoClickerRate * gameState.metaKnowledge.buffs.tickMultiplier * (1 - (gameState.resources.entropy / (MAX_ENTROPY * 2)));

      if (effectiveManualClickRate > 0.05) { 
        autoTickInterval = setInterval(() => {
           setGameState(prev => ({
            ...prev,
            resources: { ...prev.resources, ticks: prev.resources.ticks + 1 },
            totalTicksGeneratedAllTime: prev.totalTicksGeneratedAllTime + 1,
          }));
        }, Math.max(50, 1000 / effectiveManualClickRate)); // Minimum 50ms interval
      }
    }
    return () => {
      if (autoTickInterval) clearInterval(autoTickInterval);
    };
  }, [
    gameState.autoTickEnabled, 
    gameState.upgrades.cpuLevel, 
    gameState.resources.entropy, 
    gameState.metaKnowledge.buffs.tickMultiplier,
    setGameState // setGameState is stable
  ]);
};