// src/hooks/useGameLoop.ts
import { useEffect } from 'react';
import { 
  type GameState, type ActiveLayerBuffs, 
  GAME_LOOP_INTERVAL_MS, MAX_ENTROPY, ENTROPY_PER_PROCESS_PER_SEC, 
  OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL,
  BASE_TICK_RATE_PER_CPU_LEVEL, // For manual auto-clicker simulation
  AI_CORE_TICK_RATE_PER_LEVEL, // Added back for explicit AI tick calculation
  calculateEffectiveTickRate // For passive generation
} from '../types/gameState';
// Removed: import constants from '../constants/gameConfig';
import { type Toast } from '../components/ToastSystem';

interface UseGameLoopProps {
  gameState: GameState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  addToast: (message: string, type?: Toast['type']) => void;
}

export const useGameLoop = ({ gameState, setGameState, addToast }: UseGameLoopProps) => {
  // Main Game Loop for passive generation and entropy
  useEffect(() => {
    const gameLoop = setInterval(() => {
      setGameState(prev => {
        const now = Date.now();
        
        // Passive tick generation (CPU & AI)
        // calculateEffectiveTickRate already accounts for CPU and AI ticks,
        // metaKnowledge.buffs.tickMultiplier, and entropy.
        const passiveTicksPerSecond = calculateEffectiveTickRate(prev);
        const ticksThisInterval = Math.max(0, passiveTicksPerSecond / (1000 / GAME_LOOP_INTERVAL_MS));
        
        let newTicks = prev.resources.ticks + ticksThisInterval;

        // Calculate AI-specific contribution for aiAutoGeneratedTicks
        // This part should ideally be factored into calculateEffectiveTickRate if it's purely passive,
        // or handled differently if AI generation has distinct mechanics.
        // For now, let's calculate it separately based on its own rate.
        const aiContributionFactor = (1 - (prev.resources.entropy / (MAX_ENTROPY * 2)));
        const aiTicksThisInterval = (AI_CORE_TICK_RATE_PER_LEVEL * prev.upgrades.aiCoreLevel * prev.metaKnowledge.buffs.tickMultiplier * aiContributionFactor) / (1000 / GAME_LOOP_INTERVAL_MS);
        
        let newAiAutoGenerated = prev.resources.aiAutoGeneratedTicks + Math.max(0, aiTicksThisInterval);
        
        // Entropy calculation
        const runningThreadsCount = prev.layerSpecificStates.concurrencyThreads.filter(t => t.status === 'running').length;
        const totalProcessesForEntropy = prev.activeProcesses + runningThreadsCount;

        const baseEntropyGainPerSec = totalProcessesForEntropy * ENTROPY_PER_PROCESS_PER_SEC;
        const entropyReductionPerSec = prev.upgrades.optimizationLevel * OPTIMIZATION_ENTROPY_REDUCTION_PER_LEVEL * prev.metaKnowledge.buffs.entropyReductionMultiplier;
        
        const netEntropyGainPerSec = Math.max(0, baseEntropyGainPerSec - entropyReductionPerSec);
        const entropyGainThisInterval = netEntropyGainPerSec / (1000 / GAME_LOOP_INTERVAL_MS);
        const newEntropy = Math.min(MAX_ENTROPY, Math.max(0, prev.resources.entropy + entropyGainThisInterval));

        const newActiveLayerBuffs: ActiveLayerBuffs = { ...prev.activeLayerBuffs };
        // CORRECTED LINE:
        (Object.keys(newActiveLayerBuffs) as Array<keyof ActiveLayerBuffs>).forEach(layerKey => {
          const buff = newActiveLayerBuffs[layerKey];
          if (buff && buff.isActive && now >= buff.expiresAt) {
            newActiveLayerBuffs[layerKey] = null; 
            addToast(`Buff for ${layerKey} layer expired.`, 'info');
          }
        });
        
        return {
          ...prev,
          resources: {
            ...prev.resources,
            ticks: newTicks,
            entropy: newEntropy,
            aiAutoGeneratedTicks: newAiAutoGenerated,
          },
          totalTicksGeneratedAllTime: prev.totalTicksGeneratedAllTime + ticksThisInterval, // Only count main passive ticks here, or sum distinct sources
          activeLayerBuffs: newActiveLayerBuffs,
        };
      });
    }, GAME_LOOP_INTERVAL_MS);
    return () => clearInterval(gameLoop);
  }, [setGameState, addToast]);

   // Auto-tick for Machine Layer (simulated manual clicks)
   useEffect(() => {
    let autoTickInterval: NodeJS.Timeout | null = null;
    if (gameState.autoTickEnabled) {
      // Simplified auto-clicker: Rate based on CPU level.
      // Base manual click rate + per level bonus.
      // Example: 1 base + 0.5 per CPU level.
      // Let's use BASE_TICK_RATE_PER_CPU_LEVEL (0.5) for the per-level bonus for consistency.
      // A base of 1 click/sec might be too fast compared to passive generation.
      // Let's assume the "manual click" is a distinct action that generates 1 tick.
      // Its rate can be different from passive CPU tick generation.
      
      // Rate for the "auto-manual-clicker"
      // This rate is *how often* the +1 tick event occurs.
      // Let's make it similar to old logic but distinct from passive CPU generation.
      const autoClickerBaseRate = 1; // e.g., 1 "click" per second base
      const autoClickerCpuBonus = gameState.upgrades.cpuLevel * 0.2; // e.g., +0.2 "clicks" per second per CPU level
      const totalAutoClickerRate = autoClickerBaseRate + autoClickerCpuBonus;

      const effectiveManualClickRate = totalAutoClickerRate * gameState.metaKnowledge.buffs.tickMultiplier * (1 - (gameState.resources.entropy / (MAX_ENTROPY * 2)));

      if (effectiveManualClickRate > 0.05) { 
        autoTickInterval = setInterval(() => {
           setGameState(prev => ({
            ...prev,
            resources: { ...prev.resources, ticks: prev.resources.ticks + 1 }, // Generates 1 tick per "click"
            totalTicksGeneratedAllTime: prev.totalTicksGeneratedAllTime + 1,
          }));
        }, Math.max(50, 1000 / effectiveManualClickRate));
      }
    }
    return () => {
      if (autoTickInterval) clearInterval(autoTickInterval);
    };
  }, [
    gameState.autoTickEnabled, 
    gameState.upgrades.cpuLevel, 
    gameState.resources.entropy, 
    gameState.metaKnowledge.buffs.tickMultiplier,
    setGameState
  ]);
};